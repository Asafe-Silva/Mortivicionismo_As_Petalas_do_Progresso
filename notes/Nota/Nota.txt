Resumo da análise — Mortivicionismo As Pétalas do Progresso (atualizado 03/02/2026)

Resumo rápido das atualizações aplicadas:
- Corrigido crash de leitura de globals em `objects/Obj_prota_militar/Step_0.gml`: inicialização de `global.inv_peso_atual` e `global.inv_peso_max`, e proteção contra divisão por zero.
- Implementados/confirmados recursos de arma: `Obj_Walther_P38` (pickup), `Obj_bala_walther_p38` (projétil), `Obj_cartucho_walther_p38` (munição / pickup automático).
- Adicionados/utilizados scripts de trauma: `scr_trauma_create`, `scr_trauma_add`, `scr_trauma_update`, `scr_trauma_check_gatilhos`.
- Inventário/saúde/traumas inicializados em `Obj_controle/Create_0.gml`.

Observações gerais:
- As globals centrais são inicializadas em `objects/Obj_controle/Create_0.gml` (inv, peso, sanidade, traumas). Isso evita leituras não inicializadas, desde que `Obj_controle` exista na room antes do jogador.
- `Obj_prota_militar/Step_0.gml` agora contém proteções para diálogo, movimento, câmera, colisões e sistema de arma (walther). A lógica de recarga gera instâncias de `Obj_cartucho_walther_p38` que ao tocar adicionam item via `scr_item_add`.
- Os scripts de diálogo (`Script1`) implementam `scr_textos`, `ds_grid_add_text`, e estão ligados a `Obj_dialogo` para renderizar caixas de texto e escolhas.

--- Arquivos e códigos (versões atuais) ---

File: scripts/scr_trauma_update/scr_trauma_update.gml
```
function scr_trauma_update() {

    var keys = ds_map_keys(global.traumas);

    for (var i = 0; i < array_length(keys); i++) {
        var t = global.traumas[? keys[i]];

        if (!t.ativo) continue;

            // perda passiva (aplicada por passo)
            if (t.sanidade_passiva != 0) {
                scr_sanidade_change(t.sanidade_passiva);
            }
    }
}
```

File: scripts/scr_trauma_create/scr_trauma_create.gml
```
/// trauma_create(id, titulo, descricao)
function trauma_create(id, titulo, descricao) {
    var t = ds_map_create();
    ds_map_add(t, "id", id);
    ds_map_add(t, "titulo", titulo);
    ds_map_add(t, "descricao", descricao);
    ds_map_add(t, "ativo", true);
    ds_map_add(t, "sanidade_passiva", 0);
    ds_map_add(t, "resistencia", 1);
    ds_map_add(t, "gatilho", ""); // nome de script gatilho opcional
    ds_map_add(t, "tempo", 0);
    return t;
}
```

File: scripts/scr_trauma_check_gatilhos/scr_trauma_check_gatilhos.gml
```
function scr_trauma_check_gatilhos(){

	// Percorre traumas para possíveis checagens futuras.
	// Atualmente nenhum gatilho padrão é chamado aqui; função existe para extensão.
	if (!ds_map_exists(global, "traumas")) exit;
	var keys = ds_map_keys(global.traumas);
	for (var i = 0; i < array_length(keys); i++) {
		var t = global.traumas[? keys[i]];
		// placeholder: se t tiver lógica própria, pode ser processada aqui
		// ex: verificar timers, desativar trauma, etc.
		if (!t.ativo) continue;
	}
}
```

File: scripts/scr_sanidade_change/scr_sanidade_change.gml
```
function scr_sanidade_change(valor) {

    global.sanidade_atual += valor;

    if (global.sanidade_atual > global.sanidade_max)
        global.sanidade_atual = global.sanidade_max;

    if (global.sanidade_atual <= 0) {
        // colapso mental / morte
        show_debug_message("COLAPSO PSICOLÓGICO");
        // aqui você pode trocar de sprite, travar controles, etc
    }
}
```

File: scripts/scr_trauma_add/scr_trauma_add.gml
```
function scr_trauma_add(id) {

    if (ds_map_exists(global.traumas, id)) exit;

    var t;

    switch (id) {
        case "TRAUMA_FOGO":
            t = trauma_create(
                id,
                "Transtorno de Estresse Pós-Incêndio",
                "Exposição extrema a fogo e mortes em massa."
            );
            t.sanidade_passiva = -1;
            t.resistencia = 0.5;
            break;

        case "TRAUMA_PEIXE":
            t = trauma_create(
                id,
                "Ictiofobia Traumática",
                "Medo patológico de peixes vivos fora d’água."
            );
            t.sanidade_passiva = -1;
            break;
    }

    ds_map_add(global.traumas, id, t);

    // reduz sanidade máxima
    global.sanidade_max -= 5;
}
```

File: scripts/scr_item_add/scr_item_add.gml
```
function scr_item_add(item) {

    ds_list_add(global.inv, item);
    global.inv_peso_atual += item.peso;

    // impacto emocional imediato
    if (item.valor_emocional != 0) {
        scr_sanidade_change(item.valor_emocional);
    }

    // item corrompido
    if (item.corrompido && item.origem_violenta) {
        scr_sanidade_change(-5);
    }

    // gatilho de trauma
    if (item.trauma_associado != "") {
        scr_trauma_add(item.trauma_associado);
    }
}
```

File: scripts/scr_item_remove/scr_item_remove.gml
```
function scr_item_remove(index) {
    var item = global.inv[| index];
    global.inv_peso_atual -= item.peso;
    ds_list_delete(global.inv, index);
}
```

File: scripts/scr_inc_npc_estado/scr_inc_npc_estado.gml
```
/// scr_inc_npc_estado(npc)
function scr_inc_npc_estado(npc) {
    global.npc_dialogo_estado[? npc]++;
}
```

File: scripts/Script1/Script1.gml
```
/// scr_textos(npc_name)
function scr_textos(npc_name) {
    
    npc_atual = npc_name;
    var estado = scr_get_npc_estado(npc_name);
    
     // LIMPA O GRID CORRETAMENTE
    ds_grid_destroy(texto_grid);
    texto_grid = ds_grid_create(4, 0);
    
    tem_escolha = false;

    switch (npc_name) {

        case "Gatogirl":
            switch (estado) {

                case 0:
                    ds_grid_add_text("Eu amo meu namorado.", Spr_gatoman_falando, 1, "Gatogirl");
                    ds_grid_add_text("De hoje para sempre.", Spr_gatoman_falando, 1, "Gatogirl");
                    ds_grid_add_text("Amém!", Spr_gatoman_falando, 1, "Gatogirl");
                    ds_grid_add_text("Ela está rezando...?", -1, 0, "");
                    scr_inc_npc_estado("Gatogirl");
                break;

                case 1:
                    ds_grid_add_text("Ela continua rezando.", -1, 0, "");
                    ds_grid_add_text("Já é a segunda vez que vejo isso.", -1, 0, "");
                    scr_inc_npc_estado("Gatogirl");
                break;

                case 2:
                    ds_grid_add_text("Sempre a mesma oração...", -1, 0, "");
                    ds_grid_add_text("Por que ela faz isso?", -1, 0, "");
                    scr_inc_npc_estado("Gatogirl");
                break;

                default:
                    ds_grid_add_text("Eu a devo questionar?", -1, 0, "");

                    tem_escolha = true;
                    opcoes = [
                        "Sim.",
                        "Prefiro não incomodar."
                    ];
                break;
            }
        break;
        
        case "joao":
        dialog_state = 0;
            ds_grid_add_text("Sou o teu novo chefe, mulher.", Spr_Joao_Caseiro, 1, "João");
            ds_grid_add_text("E iria dar-te ouvidos, porquê?", Spr_prota_falando, 1, "Livia M.");
            ds_grid_add_text("Porque imponho respeito em todos os lugares por onde passo!", Spr_Joao_Caseiro, 1, "João");
            
            // pensamento
            ds_grid_add_text("Duvido bastante, tenho quase a certeza de que nunca o vi antes.", -1, 0, "");
            
            // existe escolha
            tem_escolha = true;
            
            opcoes = [
                "Se o senhor o diz.",
                "Irei confirmar com o general.",
                "Das interessiert mich nicht die Bohne!"
            ];

        break;

        case "Bolliver":
        dialog_state = 0;
        
            ds_grid_add_text("uma Bola ...?",  -1, 0, "r");
            ds_grid_add_text("oi?", Spr_prota_falando, 1, "Livia M.");
            ds_grid_add_text("cê que yorgute?", Spr_Bolliver, 1, "Bolliver");
            
            // pensamento
            ds_grid_add_text("Eu deveria aceitar...?", -1, 0, "");
            
            // existe escolha
            tem_escolha = true;
            
            opcoes = [
                "Sim, não tenho nada a perder",
                "não, voce é estranho :P",
                "Qual o sabor?"
            ];

        break;

    }
}

function ds_grid_add_row(){
    ///@arg ds_grid
    
    var _grid = argument[0];
    ds_grid_resize(_grid, ds_grid_width(_grid), ds_grid_height(_grid) + 1);
    return(ds_grid_height(_grid) - 1);
}

function ds_grid_add_text(){
    ///@arg texto
    ///@arg retrato
    ///@arg lado
    
    var _grid = texto_grid;
    var _y = ds_grid_add_row(_grid);
    
    _grid[# 0, _y] = argument[0];
    _grid[# 1, _y] = argument[1];
    _grid[# 2, _y] = argument[2];
    _grid[# 3, _y] = argument[3];
}
Resumo do projeto — Mortivicionismo As Pétalas do Progresso

Cena: local_de_teste
Fontes: Fnt_dialogo
Objetos: Obj_colisor; Obj_controle; Obj_dialogo; Obj_gatoman; Obj_par_npcs; Obj_prota_catsene; Obj_prota_militar; Obj_Walther_P38; Object10; Obj_Bolliver

--- Objetos (trechos relevantes) ---

Obj_controle:
	criar:
		global.dialogo = false;
		global.dialogo_lock = false;
	etapa:
		if instance_exists(Obj_dialogo){
				global.dialogo = true;
		}

Obj_dialogo:
	criar:
		npc_atual = "";
		npc_nome = "";
		pagina = 0;
		inicializar = false;
		// Máquina de digitação
		texto_completo = "";
		texto_visivel = "";
		char_index = 0;
		tempo_letra = 0;
		velocidade_base = 3;
		texto_terminou = false;
		if (!variable_global_exists("npc_dialogo_estado")) global.npc_dialogo_estado = ds_map_create();
		texto_grid = ds_grid_create(4, 0); // Texto | Retrato | Lado | Nome
		opcoes = [];
		tem_escolha = false;
		escolha_ativa = false;
		opcao_index = 0;
		dialog_state = 0;
		enum infos { Texto, Retrato, Lado, Nome }
		if (!variable_global_exists("dialogo")) global.dialogo = true;

	etapa (Step):
		// entrada para avançar (E / espaço / clique)
		var avancar = keyboard_check_pressed(ord("E")) || keyboard_check_pressed(vk_space) || mouse_check_button_pressed(mb_left);
		if (avancar && !tem_escolha) {
			if (!texto_terminou) { texto_visivel = texto_completo; texto_terminou = true; }
			else { pagina++; iniciar_digitacao(); }
		}
		// digitação progressiva
		if (!texto_terminou) { /* lógica de pausa por pontuação e incrementos */ }
		if (!inicializar) { scr_textos(npc_nome); inicializar = true; }
		if (!escolha_ativa) { if (avancar) { if (pagina < ds_grid_height(texto_grid) - 1) pagina++; else { if (tem_escolha) { escolha_ativa = true; opcao_index = 0; } else { global.dialogo = false; global.dialogo_lock = true; instance_destroy(); exit; } } } }
		if (escolha_ativa) { /* navegação por opções e confirmação -> scr_escolha_resultado(opcao_index) */ }

	desenhar (Draw_64):
		if (!inicializar) exit;
		var gw = display_get_gui_width(); var gh = display_get_gui_height(); var caixa_y = gh - 200;
		draw_rectangle_color(0, caixa_y, gw, gh, c_black, c_black, c_black, c_black, false);
		draw_set_font(Fnt_dialogo);
		draw_text_ext(32, caixa_y + 32, texto_visivel, 32, gw - 64);
		// nome com fundo e retrato à direita (se existir sprite)
		var spr = texto_grid[# infos.Retrato, pagina]; if (sprite_exists(spr)) draw_sprite_ext(spr, 0, gw - 96, gh - 96, 2, 2, 0, c_white, 1);
		// opções desenhadas quando for o último quadro e tem_escolha


Obj_prota_militar:
	criar:
		spd = 2; hsp = 0; vsp = 0;
		global.dialogo = false; global.dialogo_lock = false;
		cam_zoom = 1; cam_target_zoom = 1; cam_speed = 0.05;
		cam = view_camera[0]; cam_width = camera_get_view_width(cam); cam_height = camera_get_view_height(cam);
		move_x = 0; move_y = 0; movimento = 0; image_index = 0; olhar = 1; last_axis = "y";

	etapa (Step):
		// diálogo: se global.dialogo trava movimento e zera velocidades
		if (!variable_global_exists("dialogo")) global.dialogo = false;
		if (global.dialogo) { hsp = 0; vsp = 0; movimento = 0; exit; }
		if (!keyboard_check(ord("E"))) global.dialogo_lock = false;
		if (!global.dialogo && !global.dialogo_lock) {
			if (distance_to_object(Obj_par_npcs) <= 10) {
				if (keyboard_check_pressed(ord("E"))) {
					var npc = instance_nearest(x, y, Obj_par_npcs);
					if (instance_exists(npc)) { var d = instance_create_layer(x, y, "dialogo", Obj_dialogo); d.npc_nome = npc.nome; global.dialogo = true; global.dialogo_lock = true; }
				}
			}
		}
		// movimento, câmera suave, zoom e colisões com Obj_colisor (pixel-by-pixel)
		move_x = -(keyboard_check(vk_left)||keyboard_check(ord("A"))) + (keyboard_check(vk_right)||keyboard_check(ord("D")));
		move_y = -(keyboard_check(vk_up)||keyboard_check(ord("W"))) + (keyboard_check(vk_down)||keyboard_check(ord("S")));
		hsp = move_x * spd; vsp = move_y * spd;
		// câmera: lerp para posição do player e ajuste de tamanho
		// colisões horizontais/verticais tratadas com loops de segurança
		// atualização de sprite_index conforme movimento e last_axis


Obj_gatoman:
	criar:
		nome = "Gatogirl"

Object10:
	criar:
		nome = "joao"

Obj_Bolliver:
	criar:
		(consulte scripts → falas em `Script1`)


--- Scripts ---

Script1 (scr_textos, ds_grid helpers):
	scr_textos(npc_name): popula `texto_grid` com linhas dependentes do NPC e do estado (scr_get_npc_estado / scr_inc_npc_estado). Exemplo para `Gatogirl` e `joao` com opções e incremento de estado.

	ds_grid_add_row(): aumenta o grid em 1 linha e retorna o índice da nova linha.
	ds_grid_add_text(texto, retrato, lado, nome): adiciona uma linha ao `texto_grid` com as 4 colunas.

Trecho (resumo):
	- Para `Gatogirl`: adiciona várias linhas com `Spr_gatoman_falando` e, ao esgotar estados, ativa `tem_escolha` com opções.
	- Para `joao`: adiciona falas e define `tem_escolha` com opções.


--- Sprites (lista) ---
Spr_bala_walther_p38
Spr_bandeira_parada_mortivicionismo
Spr_Bolliver
Spr_camilly
Spr_cartucho_walther_p38
Spr_colisor
Spr_gatoman
Spr_gatoman_falando
Spr_granada_modelo_24
Spr_Joao_Caseiro
Spr_madeira
spr_missing
Spr_parede
Spr_piso
Spr_prota_Ate
Spr_prota_Ate_bom_mal
Spr_prota_baixo_militar
Spr_prota_cima_militar
Spr_prota_corendo_militar
Spr_prota_falando
Spr_prota_falando_boca_fechada
Spr_prota_parado_militar
Spr_walther_p38

Categoria (conforme suas notas iniciais):
	- armas: Spr_walther_p38, Spr_bala_walther_p38, Spr_cartucho_walther_p38
	- explosivo: Spr_granada_modelo_24
	- bandeiras: Spr_bandeira_parada_mortivicionismo
	- easter_eggs / NPCs: Spr_gatoman, Spr_gatoman_falando, Spr_Bolliver, Spr_Joao_Caseiro
	- level / tiles: Spr_colisor, Spr_madeira, Spr_parede, Spr_piso
	- protagonista: Spr_prota_* (vários)
	- fallback: spr_missing


--- Fontes ---
Fnt_dialogo (arquivo em fonts/Fnt_dialogo)


--- Salas (rooms) ---
local_de_teste/
Roo_area_de_treinamento/
Roo_cidade_destruida_pt/


--- Observações e próximos passos ---
- O diálogo usa `texto_grid` (4 colunas) e funções em `Script1` para preencher o conteúdo.
- Os objetos `Obj_prota_militar` e `Obj_controle` controlam flags globais `global.dialogo` e `global.dialogo_lock` para travar movimento.
- Para revisar/ajustar falas, edite scripts/Script1/Script1.gml (função scr_textos).

Se quiser, eu:
- Posso incluir o conteúdo completo de cada `Create/Step/Draw` inline (mais verboso).
- Posso gerar uma versão do Nota.txt com separação por cena real (consigo ler os .yy das rooms para listar objetos colocados nelas).
